# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `curb` gem.
# Please instead update this file by running `bin/tapioca gem curb`.

# expose shortcut methods
#
# source://curb//lib/curl/easy.rb#2
module Curl
  class << self
    def asyncdns?; end
    def conv?; end
    def debug?; end

    # source://curb//lib/curl.rb#42
    def delete(url, params = T.unsafe(nil), &block); end

    # source://curb//lib/curl.rb#30
    def get(url, params = T.unsafe(nil), &block); end

    def gssnegotiate?; end

    # source://curb//lib/curl.rb#50
    def head(url, params = T.unsafe(nil), &block); end

    # source://curb//lib/curl.rb#11
    def http(verb, url, post_body = T.unsafe(nil), put_data = T.unsafe(nil), &block); end

    def http2?; end
    def idn?; end
    def ipv6?; end
    def kerberos4?; end
    def largefile?; end
    def libz?; end
    def ntlm?; end

    # source://curb//lib/curl.rb#54
    def options(url, params = T.unsafe(nil), &block); end

    # source://curb//lib/curl.rb#46
    def patch(url, params = T.unsafe(nil), &block); end

    # source://curb//lib/curl.rb#34
    def post(url, params = T.unsafe(nil), &block); end

    # source://curb//lib/curl.rb#68
    def postalize(params = T.unsafe(nil)); end

    # source://curb//lib/curl.rb#38
    def put(url, params = T.unsafe(nil), &block); end

    # source://curb//lib/curl.rb#72
    def reset; end

    def spnego?; end
    def ssl?; end
    def sspi?; end

    # source://curb//lib/curl.rb#58
    def urlalize(url, params = T.unsafe(nil)); end
  end
end

Curl::CURB_VERSION = T.let(T.unsafe(nil), String)
Curl::CURLAUTH_ANY = T.let(T.unsafe(nil), Integer)
Curl::CURLAUTH_ANYSAFE = T.let(T.unsafe(nil), Integer)
Curl::CURLAUTH_BASIC = T.let(T.unsafe(nil), Integer)
Curl::CURLAUTH_DIGEST = T.let(T.unsafe(nil), Integer)
Curl::CURLAUTH_DIGEST_IE = T.let(T.unsafe(nil), Integer)
Curl::CURLAUTH_GSSNEGOTIATE = T.let(T.unsafe(nil), Integer)
Curl::CURLAUTH_NTLM = T.let(T.unsafe(nil), Integer)
Curl::CURLAUTH_ONLY = T.let(T.unsafe(nil), Integer)
Curl::CURLFTPAUTH_DEFAULT = T.let(T.unsafe(nil), Integer)
Curl::CURLFTPAUTH_SSL = T.let(T.unsafe(nil), Integer)
Curl::CURLFTPAUTH_TLS = T.let(T.unsafe(nil), Integer)
Curl::CURLFTPMETHOD_MULTICWD = T.let(T.unsafe(nil), Integer)
Curl::CURLFTPMETHOD_NOCWD = T.let(T.unsafe(nil), Integer)
Curl::CURLFTPMETHOD_SINGLECWD = T.let(T.unsafe(nil), Integer)
Curl::CURLFTPSSL_CCC_ACTIVE = T.let(T.unsafe(nil), Integer)
Curl::CURLFTPSSL_CCC_NONE = T.let(T.unsafe(nil), Integer)
Curl::CURLFTPSSL_CCC_PASSIVE = T.let(T.unsafe(nil), Integer)
Curl::CURLGSSAPI_DELEGATION_FLAG = T.let(T.unsafe(nil), Integer)
Curl::CURLGSSAPI_DELEGATION_POLICY_FLAG = T.let(T.unsafe(nil), Integer)
Curl::CURLINFO_DATA_IN = T.let(T.unsafe(nil), Integer)
Curl::CURLINFO_DATA_OUT = T.let(T.unsafe(nil), Integer)
Curl::CURLINFO_HEADER_IN = T.let(T.unsafe(nil), Integer)
Curl::CURLINFO_HEADER_OUT = T.let(T.unsafe(nil), Integer)
Curl::CURLINFO_TEXT = T.let(T.unsafe(nil), Integer)
Curl::CURLKHSTAT_DEFER = T.let(T.unsafe(nil), Integer)
Curl::CURLKHSTAT_FINE = T.let(T.unsafe(nil), Integer)
Curl::CURLKHSTAT_FINE_ADD_TO_FILE = T.let(T.unsafe(nil), Integer)
Curl::CURLKHSTAT_REJECT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_ADDRESS_SCOPE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_APPEND = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_AUTOREFERER = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_BUFFERSIZE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_CAINFO = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_CAPATH = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_CERTINFO = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_CHUNK_BGN_FUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_CHUNK_DATA = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_CHUNK_END_FUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_CLOSEPOLICY = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_CONNECTTIMEOUT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_CONNECTTIMEOUT_MS = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_CONNECT_ONLY = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_CONV_FROM_NETWORK_FUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_CONV_FROM_UTF8_FUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_CONV_TO_NETWORK_FUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_COOKIE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_COOKIEFILE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_COOKIEJAR = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_COOKIELIST = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_COOKIESESSION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_COPYPOSTFIELDS = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_CRLF = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_CRLFILE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_CUSTOMREQUEST = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_DEBUGDATA = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_DEBUGFUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_DIRLISTONLY = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_DNS_CACHE_TIMEOUT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_DNS_USE_GLOBAL_CACHE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_EGDSOCKET = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_ENCODING = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_ERRORBUFFER = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FAILONERROR = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FILETIME = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FNMATCH_DATA = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FNMATCH_FUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FOLLOWLOCATION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FORBID_REUSE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FRESH_CONNECT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FTPPORT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FTPSSLAUTH = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FTP_ACCOUNT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FTP_ALTERNATIVE_TO_USER = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FTP_CREATE_MISSING_DIRS = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FTP_FILEMETHOD = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FTP_RESPONSE_TIMEOUT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FTP_SKIP_PASV_IP = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FTP_SSL_CCC = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FTP_USE_EPRT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FTP_USE_EPSV = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_FTP_USE_PRET = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_GSSAPI_DELEGATION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_HAPROXYPROTOCOL = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_HEADER = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_HEADERFUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_HTTP200ALIASES = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_HTTPAUTH = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_HTTPGET = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_HTTPHEADER = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_HTTPPOST = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_HTTPPROXYTUNNEL = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_HTTP_CONTENT_DECODING = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_HTTP_TRANSFER_DECODING = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_HTTP_VERSION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_IGNORE_CONTENT_LENGTH = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_INFILESIZE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_INFILESIZE_LARGE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_INTERFACE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_INTERLEAVEDATA = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_INTERLEAVEFUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_IOCTLDATA = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_IOCTLFUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_IPRESOLVE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_ISSUERCERT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_KEYPASSWD = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_KRBLEVEL = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_LOCALPORT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_LOW_SPEED_LIMIT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_LOW_SPEED_TIME = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_MAIL_FROM = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_MAIL_RCPT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_MAXCONNECTS = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_MAXFILESIZE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_MAXFILESIZE_LARGE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_MAXREDIRS = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_MAX_RECV_SPEED_LARGE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_MAX_SEND_SPEED_LARGE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_NETRC = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_NETRC_FILE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_NEW_DIRECTORY_PERMS = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_NEW_FILE_PERMS = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_NOBODY = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_NOPROGRESS = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_NOPROXY = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_NOSIGNAL = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_OPENSOCKETDATA = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_OPENSOCKETFUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PASSWORD = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PATH_AS_IS = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PIPEWAIT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PORT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_POST = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_POSTFIELDS = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_POSTFIELDSIZE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_POSTFIELDSIZE_LARGE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_POSTQUOTE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_POSTREDIR = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PREQUOTE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PRIVATE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PROGRESSDATA = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PROGRESSFUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PROTOCOLS = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PROXY = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PROXYAUTH = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PROXYHEADER = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PROXYPORT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PROXYTYPE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PROXYUSERPWD = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PROXY_SSL_VERIFYHOST = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PROXY_TRANSFER_MODE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_PUT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_QUOTE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_RANDOM_FILE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_RANGE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_READDATA = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_READFUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_REDIR_PROTOCOLS = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_REFERER = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_RESOLVE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_RESUME_FROM = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_RESUME_FROM_LARGE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_RTSP_CLIENT_CSEQ = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_RTSP_REQUEST = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_RTSP_SERVER_CSEQ = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_RTSP_SESSION_ID = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_RTSP_STREAM_URI = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_RTSP_TRANSPORT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SEEKDATA = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SEEKFUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SHARE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SOCKOPTDATA = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SOCKOPTFUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SOCKS5_GSSAPI_NEC = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SOCKS5_GSSAPI_SERVICE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSH_AUTH_TYPES = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSH_HOST_PUBLIC_KEY_MD5 = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSH_KEYDATA = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSH_KEYFUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSH_KNOWNHOSTS = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSH_PRIVATE_KEYFILE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSH_PUBLIC_KEYFILE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSLCERT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSLCERTTYPE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSLENGINE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSLENGINE_DEFAULT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSLKEY = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSLKEYTYPE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSLVERSION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSL_CIPHER_LIST = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSL_CTX_DATA = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSL_CTX_FUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSL_SESSIONID_CACHE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSL_VERIFYHOST = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_SSL_VERIFYPEER = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_STDERR = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_TCP_KEEPALIVE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_TCP_KEEPIDLE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_TCP_KEEPINTVL = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_TCP_NODELAY = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_TELNETOPTIONS = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_TFTP_BLKSIZE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_TIMECONDITION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_TIMEOUT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_TIMEOUT_MS = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_TIMEVALUE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_TLSAUTH_PASSWORD = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_TLSAUTH_TYPE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_TLSAUTH_USERNAME = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_TRANSFERTEXT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_UNIX_SOCKET_PATH = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_UNRESTRICTED_AUTH = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_UPLOAD = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_URL = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_USERAGENT = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_USERNAME = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_USERPWD = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_USE_SSL = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_VERBOSE = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_WRITEDATA = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_WRITEFUNCTION = T.let(T.unsafe(nil), Integer)
Curl::CURLOPT_WRITEHEADER = T.let(T.unsafe(nil), Integer)
Curl::CURLPIPE_HTTP1 = T.let(T.unsafe(nil), Integer)
Curl::CURLPIPE_MULTIPLEX = T.let(T.unsafe(nil), Integer)
Curl::CURLPIPE_NOTHING = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_ALL = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_DICT = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_FILE = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_FTP = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_FTPS = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_GOPHER = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_HTTP = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_HTTPS = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_IMAP = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_IMAPS = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_LDAP = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_LDAPS = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_POP3 = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_POP3S = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_RTMP = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_RTMPE = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_RTMPS = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_RTMPT = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_RTMPTE = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_RTMPTS = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_RTSP = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_SCP = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_SFTP = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_SMB = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_SMBS = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_SMTP = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_SMTPS = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_TELNET = T.let(T.unsafe(nil), Integer)
Curl::CURLPROTO_TFTP = T.let(T.unsafe(nil), Integer)
Curl::CURLPROXY_HTTP = T.let(T.unsafe(nil), Integer)
Curl::CURLPROXY_SOCKS4 = T.let(T.unsafe(nil), Integer)
Curl::CURLPROXY_SOCKS4A = T.let(T.unsafe(nil), Integer)
Curl::CURLPROXY_SOCKS5 = T.let(T.unsafe(nil), Integer)
Curl::CURLPROXY_SOCKS5_HOSTNAME = T.let(T.unsafe(nil), Integer)
Curl::CURLUSESSL_ALL = T.let(T.unsafe(nil), Integer)
Curl::CURLUSESSL_CONTROL = T.let(T.unsafe(nil), Integer)
Curl::CURLUSESSL_NONE = T.let(T.unsafe(nil), Integer)
Curl::CURLUSESSL_TRY = T.let(T.unsafe(nil), Integer)
Curl::CURL_HTTP_VERSION_1_0 = T.let(T.unsafe(nil), Integer)
Curl::CURL_HTTP_VERSION_1_1 = T.let(T.unsafe(nil), Integer)
Curl::CURL_HTTP_VERSION_2TLS = T.let(T.unsafe(nil), Integer)
Curl::CURL_HTTP_VERSION_2_0 = T.let(T.unsafe(nil), Integer)
Curl::CURL_HTTP_VERSION_NONE = T.let(T.unsafe(nil), Integer)
Curl::CURL_IPRESOLVE_V4 = T.let(T.unsafe(nil), Integer)
Curl::CURL_IPRESOLVE_V6 = T.let(T.unsafe(nil), Integer)
Curl::CURL_IPRESOLVE_WHATEVER = T.let(T.unsafe(nil), Integer)
Curl::CURL_LONG_VERSION = T.let(T.unsafe(nil), String)
Curl::CURL_MULTICWD = T.let(T.unsafe(nil), Integer)
Curl::CURL_NETRC_IGNORED = T.let(T.unsafe(nil), Integer)
Curl::CURL_NETRC_OPTIONAL = T.let(T.unsafe(nil), Integer)
Curl::CURL_NETRC_REQUIRED = T.let(T.unsafe(nil), Integer)
Curl::CURL_NOCWD = T.let(T.unsafe(nil), Integer)
Curl::CURL_RTSPREQ_ANNOUNCE = T.let(T.unsafe(nil), Integer)
Curl::CURL_RTSPREQ_DESCRIBE = T.let(T.unsafe(nil), Integer)
Curl::CURL_RTSPREQ_GET_PARAMETER = T.let(T.unsafe(nil), Integer)
Curl::CURL_RTSPREQ_OPTIONS = T.let(T.unsafe(nil), Integer)
Curl::CURL_RTSPREQ_PAUSE = T.let(T.unsafe(nil), Integer)
Curl::CURL_RTSPREQ_PLAY = T.let(T.unsafe(nil), Integer)
Curl::CURL_RTSPREQ_RECEIVE = T.let(T.unsafe(nil), Integer)
Curl::CURL_RTSPREQ_RECORD = T.let(T.unsafe(nil), Integer)
Curl::CURL_RTSPREQ_SETUP = T.let(T.unsafe(nil), Integer)
Curl::CURL_RTSPREQ_SET_PARAMETER = T.let(T.unsafe(nil), Integer)
Curl::CURL_RTSPREQ_TEARDOWN = T.let(T.unsafe(nil), Integer)
Curl::CURL_SINGLECWD = T.let(T.unsafe(nil), Integer)
Curl::CURL_SSLVERSION_DEFAULT = T.let(T.unsafe(nil), Integer)
Curl::CURL_SSLVERSION_MAX_DEFAULT = T.let(T.unsafe(nil), Integer)
Curl::CURL_SSLVERSION_MAX_TLSv1_0 = T.let(T.unsafe(nil), Integer)
Curl::CURL_SSLVERSION_MAX_TLSv1_1 = T.let(T.unsafe(nil), Integer)
Curl::CURL_SSLVERSION_MAX_TLSv1_2 = T.let(T.unsafe(nil), Integer)
Curl::CURL_SSLVERSION_MAX_TLSv1_3 = T.let(T.unsafe(nil), Integer)
Curl::CURL_SSLVERSION_SSLv2 = T.let(T.unsafe(nil), Integer)
Curl::CURL_SSLVERSION_SSLv3 = T.let(T.unsafe(nil), Integer)
Curl::CURL_SSLVERSION_TLSv1 = T.let(T.unsafe(nil), Integer)
Curl::CURL_SSLVERSION_TLSv1_0 = T.let(T.unsafe(nil), Integer)
Curl::CURL_SSLVERSION_TLSv1_1 = T.let(T.unsafe(nil), Integer)
Curl::CURL_SSLVERSION_TLSv1_2 = T.let(T.unsafe(nil), Integer)
Curl::CURL_SSLVERSION_TLSv1_3 = T.let(T.unsafe(nil), Integer)
Curl::CURL_USESSL_ALL = T.let(T.unsafe(nil), Integer)
Curl::CURL_USESSL_CONTROL = T.let(T.unsafe(nil), Integer)
Curl::CURL_USESSL_NONE = T.let(T.unsafe(nil), Integer)
Curl::CURL_USESSL_TRY = T.let(T.unsafe(nil), Integer)
Curl::CURL_VERNUM = T.let(T.unsafe(nil), Integer)
Curl::CURL_VERSION = T.let(T.unsafe(nil), String)

# source://curb//lib/curl/easy.rb#3
class Curl::Easy
  def initialize(*_arg0); end

  def app_connect_time; end
  def autoreferer=(_arg0); end
  def body; end
  def body_str; end
  def cacert; end
  def cacert=(_arg0); end
  def cert; end
  def cert=(_arg0); end
  def cert_key; end
  def cert_key=(_arg0); end
  def certpassword=(_arg0); end
  def certtype; end
  def certtype=(_arg0); end
  def clone; end
  def close; end
  def code; end
  def connect_time; end
  def connect_timeout; end
  def connect_timeout=(_arg0); end
  def connect_timeout_ms; end
  def connect_timeout_ms=(_arg0); end
  def content_type; end
  def cookiefile; end

  # call-seq:
  #   easy.cookiefile = string                         => string
  #
  # Set a file that contains cookies to be sent in subsequent requests by this Curl::Easy instance.
  #
  # *Note* that you must set enable_cookies true to enable the cookie
  # engine, or this option will be ignored.
  #
  # source://curb//lib/curl/easy.rb#236
  def cookiefile=(value); end

  def cookiejar; end

  # call-seq:
  #   easy.cookiejar = string                          => string
  #
  # Set a cookiejar file to use for this Curl::Easy instance.
  # Cookies from the response will be written into this file.
  #
  # *Note* that you must set enable_cookies true to enable the cookie
  # engine, or this option will be ignored.
  #
  # source://curb//lib/curl/easy.rb#250
  def cookiejar=(value); end

  def cookielist; end
  def cookies; end

  # call-seq:
  #   easy.cookies = "name1=content1; name2=content2;" => string
  #
  # Set cookies to be sent by this Curl::Easy instance. The format of the string should
  # be NAME=CONTENTS, where NAME is the cookie name and CONTENTS is what the cookie should contain.
  # Set multiple cookies in one string like this: "name1=content1; name2=content2;" etc.
  #
  # source://curb//lib/curl/easy.rb#223
  def cookies=(value); end

  # call-seq:
  #   easy.http_delete
  #
  # DELETE the currently configured URL using the current options set for
  # this Curl::Easy instance. This method always returns true, or raises
  # an exception (defined under Curl::Err) on error.
  #
  # source://curb//lib/curl/easy.rb#315
  def delete; end

  # call-seq:
  #   easy = Curl::Easy.new("url") do|c|
  #    c.delete = true
  #   end
  #   easy.perform
  #
  # source://curb//lib/curl/easy.rb#103
  def delete=(onoff); end

  def dns_cache_timeout; end
  def dns_cache_timeout=(_arg0); end
  def download_speed; end
  def downloaded_bytes; end
  def downloaded_content_length; end
  def dup; end
  def enable_cookies=(_arg0); end
  def enable_cookies?; end
  def encoding; end
  def encoding=(_arg0); end
  def escape(_arg0); end
  def fetch_file_time=(_arg0); end
  def fetch_file_time?; end
  def file_time; end

  # call-seq:
  #   easy.follow_location = boolean                   => boolean
  #
  # Configure whether this Curl instance will follow Location: headers
  # in HTTP responses. Redirects will only be followed to the extent
  # specified by +max_redirects+.
  #
  # source://curb//lib/curl/easy.rb#273
  def follow_location=(onoff); end

  def follow_location?; end
  def ftp_commands; end
  def ftp_commands=(_arg0); end
  def ftp_entry_path; end
  def ftp_filemethod; end
  def ftp_filemethod=(_arg0); end
  def ftp_response_timeout; end
  def ftp_response_timeout=(_arg0); end

  # call-seq:
  #   easy.http_get                                    => true
  #
  # GET the currently configured URL using the current options set for
  # this Curl::Easy instance. This method always returns true, or raises
  # an exception (defined under Curl::Err) on error.
  #
  # source://curb//lib/curl/easy.rb#301
  def get; end

  def getinfo(_arg0); end
  def head; end

  # call-seq:
  #  easy = Curl::Easy.new("url") do|c|
  #   c.head = true
  #  end
  #  easy.perform
  #
  # source://curb//lib/curl/easy.rb#261
  def head=(onoff); end

  def header_in_body=(_arg0); end
  def header_in_body?; end
  def header_size; end
  def header_str; end
  def headers; end
  def headers=(_arg0); end
  def http(_arg0); end
  def http_auth_types; end
  def http_auth_types=(*_arg0); end
  def http_connect_code; end

  # call-seq:
  #   easy.http_delete
  #
  # DELETE the currently configured URL using the current options set for
  # this Curl::Easy instance. This method always returns true, or raises
  # an exception (defined under Curl::Err) on error.
  #
  # source://curb//lib/curl/easy.rb#315
  def http_delete; end

  # call-seq:
  #   easy.http_get                                    => true
  #
  # GET the currently configured URL using the current options set for
  # this Curl::Easy instance. This method always returns true, or raises
  # an exception (defined under Curl::Err) on error.
  #
  # source://curb//lib/curl/easy.rb#301
  def http_get; end

  # call-seq:
  #   easy.http_head                                   => true
  #
  # Request headers from the currently configured URL using the HEAD
  # method and current options set for this Curl::Easy instance. This
  # method always returns true, or raises an exception (defined under
  # Curl::Err) on error.
  #
  # source://curb//lib/curl/easy.rb#286
  def http_head; end

  def http_post(*_arg0); end
  def http_put(_arg0); end
  def ignore_content_length=(_arg0); end
  def ignore_content_length?; end
  def inspect; end
  def interface; end

  # call-seq:
  #   easy.interface = string                          => string
  #
  # Set the interface name to use as the outgoing network interface.
  # The name can be an interface name, an IP address or a host name.
  #
  # source://curb//lib/curl/easy.rb#188
  def interface=(value); end

  def last_effective_url; end
  def last_error; end
  def last_result; end
  def local_port; end
  def local_port=(_arg0); end
  def local_port_range; end
  def local_port_range=(_arg0); end
  def low_speed_limit; end
  def low_speed_limit=(_arg0); end
  def low_speed_time; end
  def low_speed_time=(_arg0); end
  def max_recv_speed_large; end
  def max_recv_speed_large=(_arg0); end
  def max_redirects; end
  def max_redirects=(_arg0); end
  def max_send_speed_large; end
  def max_send_speed_large=(_arg0); end
  def multi; end
  def multi=(_arg0); end
  def multipart_form_post=(_arg0); end
  def multipart_form_post?; end
  def name_lookup_time; end

  # call-seq:
  #
  # easy = Curl::Easy.new
  # easy.nosignal = true
  #
  # source://curb//lib/curl/easy.rb#92
  def nosignal=(onoff); end

  def num_connects; end
  def on_body(*_arg0); end
  def on_complete(*_arg0); end
  def on_debug(*_arg0); end
  def on_failure(*_arg0); end
  def on_header(*_arg0); end
  def on_missing(*_arg0); end
  def on_progress(*_arg0); end
  def on_redirect(*_arg0); end
  def on_success(*_arg0); end
  def os_errno; end
  def password; end
  def password=(_arg0); end

  # call-seq:
  #   easy.perform                                     => true
  #
  # Transfer the currently configured URL using the options set for this
  # Curl::Easy instance. If this is an HTTP URL, it will be transferred via
  # the configured HTTP Verb.
  #
  # source://curb//lib/curl/easy.rb#66
  def perform; end

  def post(*_arg0); end
  def post_body; end
  def post_body=(_arg0); end
  def pre_transfer_time; end
  def primary_ip; end
  def proxy_auth_types; end
  def proxy_auth_types=(_arg0); end
  def proxy_headers; end
  def proxy_headers=(_arg0); end
  def proxy_port; end
  def proxy_port=(_arg0); end
  def proxy_tunnel=(_arg0); end
  def proxy_tunnel?; end
  def proxy_type; end
  def proxy_type=(_arg0); end
  def proxy_url; end

  # call-seq:
  #   easy.proxy_url = string                          => string
  #
  # Set the URL of the HTTP proxy to use for subsequent calls to +perform+.
  # The URL should specify the the host name or dotted IP address. To specify
  # port number in this string, append :[port] to the end of the host name.
  # The proxy string may be prefixed with [protocol]:// since any such prefix
  # will be ignored. The proxy's port number may optionally be specified with
  # the separate option proxy_port .
  #
  # When you tell the library to use an HTTP proxy, libcurl will transparently
  # convert operations to HTTP even if you specify an FTP URL etc. This may have
  # an impact on what other features of the library you can use, such as
  # FTP specifics that don't work unless you tunnel through the HTTP proxy. Such
  # tunneling is activated with proxy_tunnel = true.
  #
  # libcurl respects the environment variables *http_proxy*, *ftp_proxy*,
  # *all_proxy* etc, if any of those is set. The proxy_url option does however
  # override any possibly set environment variables.
  #
  # Starting with libcurl 7.14.1, the proxy host string given in environment
  # variables can be specified the exact same way as the proxy can be set with
  # proxy_url, including protocol prefix (http://) and embedded user + password.
  #
  # source://curb//lib/curl/easy.rb#157
  def proxy_url=(url); end

  def proxypwd; end

  # call-seq:
  #   easy.proxypwd = string                           => string
  #
  # Set the username/password string to use for proxy connection during
  # subsequent calls to +perform+. The supplied string should have the
  # form "username:password"
  #
  # source://curb//lib/curl/easy.rb#211
  def proxypwd=(value); end

  def put(_arg0); end
  def put_data=(_arg0); end
  def redirect_count; end
  def redirect_time; end
  def redirect_url; end
  def request_size; end
  def reset; end
  def resolve; end
  def resolve=(_arg0); end
  def resolve_mode; end
  def resolve_mode=(_arg0); end
  def response_code; end

  # call-seq:
  #   easy.set :sym|Fixnum, value
  #
  # set options on the curl easy handle see http://curl.haxx.se/libcurl/c/curl_easy_setopt.html
  #
  # source://curb//lib/curl/easy.rb#34
  def set(opt, val); end

  def setopt(_arg0, _arg1); end
  def ssl_verify_host; end

  # source://curb//lib/curl/easy.rb#161
  def ssl_verify_host=(value); end

  # call-seq:
  #   easy.ssl_verify_host?                            => boolean
  #
  # Deprecated: call easy.ssl_verify_host instead
  # can be one of [0,1,2]
  #
  # Determine whether this Curl instance will verify that the server cert
  # is for the server it is known as.
  #
  # @return [Boolean]
  #
  # source://curb//lib/curl/easy.rb#177
  def ssl_verify_host?; end

  def ssl_verify_host_integer=(_arg0); end
  def ssl_verify_peer=(_arg0); end
  def ssl_verify_peer?; end
  def ssl_verify_result; end
  def ssl_version; end
  def ssl_version=(_arg0); end
  def start_transfer_time; end

  # call-seq:
  #   easy.status  => String
  #
  # source://curb//lib/curl/easy.rb#22
  def status; end

  # call-seq:
  #   easy.sym2curl :symbol => Fixnum
  #
  #  translates ruby symbols to libcurl options
  #
  # source://curb//lib/curl/easy.rb#54
  def sym2curl(opt); end

  def timeout; end
  def timeout=(_arg0); end
  def timeout_ms; end
  def timeout_ms=(_arg0); end
  def total_time; end
  def unescape(_arg0); end
  def unrestricted_auth=(_arg0); end
  def unrestricted_auth?; end
  def upload_speed; end
  def uploaded_bytes; end
  def uploaded_content_length; end
  def url; end

  # call-seq:
  #   easy.url = "http://some.url/"                    => "http://some.url/"
  #
  # Set the URL for subsequent calls to +perform+. It is acceptable
  # (and even recommended) to reuse Curl::Easy instances by reassigning
  # the URL between calls to +perform+.
  #
  # source://curb//lib/curl/easy.rb#128
  def url=(u); end

  def use_netrc=(_arg0); end
  def use_netrc?; end
  def use_ssl; end
  def use_ssl=(_arg0); end
  def useragent; end
  def useragent=(_arg0); end
  def username; end
  def username=(_arg0); end
  def userpwd; end

  # call-seq:
  #   easy.userpwd = string                            => string
  #
  # Set the username/password string to use for subsequent calls to +perform+.
  # The supplied string should have the form "username:password"
  #
  # source://curb//lib/curl/easy.rb#199
  def userpwd=(value); end

  def verbose=(_arg0); end
  def verbose?; end

  # call-seq:
  #
  #  easy = Curl::Easy.new("url")
  #  easy.version = Curl::HTTP_2_0
  #  easy.version = Curl::HTTP_1_1
  #  easy.version = Curl::HTTP_1_0
  #  easy.version = Curl::HTTP_NONE
  #
  # source://curb//lib/curl/easy.rb#116
  def version=(http_version); end

  class << self
    # call-seq:
    #   Curl::Easy.download(url, filename = url.split(/\?/).first.split(/\//).last) { |curl| ... }
    #
    # Stream the specified url (via perform) and save the data directly to the
    # supplied filename (defaults to the last component of the URL path, which will
    # usually be the filename most simple urls).
    #
    # If a block is supplied, it will be passed the curl instance prior to the
    # perform call.
    #
    # *Note* that the semantics of the on_body handler are subtly changed when using
    # download, to account for the automatic routing of data to the specified file: The
    # data string is passed to the handler *before* it is written
    # to the file, allowing the handler to perform mutative operations where
    # necessary. As usual, the transfer will be aborted if the on_body handler
    # returns a size that differs from the data chunk size - in this case, the
    # offending chunk will *not* be written to the file, the file will be closed,
    # and a Curl::Err::AbortedByCallbackError will be raised.
    #
    # source://curb//lib/curl/easy.rb#446
    def download(url, filename = T.unsafe(nil), &blk); end

    def error(_arg0); end

    # call-seq:
    #   Curl::Easy.http_delete(url) { |easy| ... }       => #<Curl::Easy...>
    #
    # Convenience method that creates a new Curl::Easy instance with
    # the specified URL and calls +http_delete+, before returning the new instance.
    #
    # If a block is supplied, the new instance will be yielded just prior to
    # the +http_delete+ call.
    #
    # @yield [c]
    #
    # source://curb//lib/curl/easy.rb#421
    def http_delete(*args); end

    # call-seq:
    #   Curl::Easy.http_get(url) { |easy| ... }          => #<Curl::Easy...>
    #
    # Convenience method that creates a new Curl::Easy instance with
    # the specified URL and calls +http_get+, before returning the new instance.
    #
    # If a block is supplied, the new instance will be yielded just prior to
    # the +http_get+ call.
    #
    # @yield [c]
    #
    # source://curb//lib/curl/easy.rb#350
    def http_get(*args); end

    # call-seq:
    #   Curl::Easy.http_head(url) { |easy| ... }         => #<Curl::Easy...>
    #
    # Convenience method that creates a new Curl::Easy instance with
    # the specified URL and calls +http_head+, before returning the new instance.
    #
    # If a block is supplied, the new instance will be yielded just prior to
    # the +http_head+ call.
    #
    # @yield [c]
    #
    # source://curb//lib/curl/easy.rb#367
    def http_head(*args); end

    # call-seq:
    #   Curl::Easy.http_post(url, "some=urlencoded%20form%20data&and=so%20on") => true
    #   Curl::Easy.http_post(url, "some=urlencoded%20form%20data", "and=so%20on", ...) => true
    #   Curl::Easy.http_post(url, "some=urlencoded%20form%20data", Curl::PostField, "and=so%20on", ...) => true
    #   Curl::Easy.http_post(url, Curl::PostField, Curl::PostField ..., Curl::PostField) => true
    #
    # POST the specified formdata to the currently configured URL using
    # the current options set for this Curl::Easy instance. This method
    # always returns true, or raises an exception (defined under
    # Curl::Err) on error.
    #
    # If you wish to use multipart form encoding, you'll need to supply a block
    # in order to set multipart_form_post true. See #http_post for more
    # information.
    #
    # @yield [c]
    #
    # source://curb//lib/curl/easy.rb#403
    def http_post(*args); end

    # call-seq:
    #   Curl::Easy.http_put(url, data) {|c| ... }
    #
    # see easy.http_put
    #
    # @yield [c]
    #
    # source://curb//lib/curl/easy.rb#380
    def http_put(url, data); end

    # call-seq:
    #   Curl::Easy.perform(url) { |easy| ... }           => #<Curl::Easy...>
    #
    # Convenience method that creates a new Curl::Easy instance with
    # the specified URL and calls the general +perform+ method, before returning
    # the new instance. For HTTP URLs, this is equivalent to calling +http_get+.
    #
    # If a block is supplied, the new instance will be yielded just prior to
    # the +http_get+ call.
    #
    # @yield [c]
    #
    # source://curb//lib/curl/easy.rb#333
    def perform(*args); end
  end
end

# source://curb//lib/curl/easy.rb#10
class Curl::Easy::Error < ::StandardError
  # @return [Error] a new instance of Error
  #
  # source://curb//lib/curl/easy.rb#12
  def initialize(code, msg); end

  # Returns the value of attribute code.
  #
  # source://curb//lib/curl/easy.rb#11
  def code; end

  # Sets the attribute code
  #
  # @param value the value to set the attribute code to.
  #
  # source://curb//lib/curl/easy.rb#11
  def code=(_arg0); end

  # Returns the value of attribute message.
  #
  # source://curb//lib/curl/easy.rb#11
  def message; end

  # Sets the attribute message
  #
  # @param value the value to set the attribute message to.
  #
  # source://curb//lib/curl/easy.rb#11
  def message=(_arg0); end
end

module Curl::Err; end
class Curl::Err::AbortedByCallbackError < ::Curl::Err::CurlError; end
class Curl::Err::AccessDeniedError < ::Curl::Err::FTPError; end
class Curl::Err::Again < ::Curl::Err::CurlError; end
class Curl::Err::BadCallingOrderError < ::Curl::Err::CurlError; end
class Curl::Err::BadContentEncodingError < ::Curl::Err::CurlError; end
class Curl::Err::BadFileListError < ::Curl::Err::FTPError; end
class Curl::Err::BadFunctionArgumentError < ::Curl::Err::CurlError; end
class Curl::Err::BadOptionSyntaxError < ::Curl::Err::TelnetError; end
class Curl::Err::BadPasswordEnteredError < ::Curl::Err::CurlError; end
class Curl::Err::BadPasswordError < ::Curl::Err::FTPError; end
class Curl::Err::BadResumeError < ::Curl::Err::CurlError; end
class Curl::Err::CantGetHostError < ::Curl::Err::FTPError; end
class Curl::Err::CantReconnectError < ::Curl::Err::FTPError; end
class Curl::Err::ChunkFailedError < ::Curl::Err::CurlError; end
class Curl::Err::ConnectionFailedError < ::Curl::Err::CurlError; end
class Curl::Err::ConvFailed < ::Curl::Err::CurlError; end
class Curl::Err::ConvReqd < ::Curl::Err::CurlError; end
class Curl::Err::CouldntBindError < ::Curl::Err::LDAPError; end
class Curl::Err::CouldntGetSizeError < ::Curl::Err::FTPError; end
class Curl::Err::CouldntReadError < ::Curl::Err::FileError; end
class Curl::Err::CouldntRetrFileError < ::Curl::Err::FTPError; end
class Curl::Err::CouldntSetASCIIError < ::Curl::Err::FTPError; end
class Curl::Err::CouldntSetBinaryError < ::Curl::Err::FTPError; end
class Curl::Err::CouldntStorFileError < ::Curl::Err::FTPError; end
class Curl::Err::CouldntUseRestError < ::Curl::Err::FTPError; end
class Curl::Err::CseqError < ::Curl::Err::RTSPError; end
class Curl::Err::CurlError < ::RuntimeError; end
class Curl::Err::CurlOK < ::Curl::Err::CurlError; end
class Curl::Err::DiskFullError < ::Curl::Err::TFTPError; end
class Curl::Err::FTPError < ::Curl::Err::CurlError; end
class Curl::Err::FTPQuoteError < ::Curl::Err::FTPError; end
class Curl::Err::FTPSSLFailed < ::Curl::Err::FTPError; end
class Curl::Err::FTPWriteError < ::Curl::Err::FTPError; end
class Curl::Err::FailedInitError < ::Curl::Err::CurlError; end
class Curl::Err::FileError < ::Curl::Err::CurlError; end
class Curl::Err::FileExistsError < ::Curl::Err::TFTPError; end
class Curl::Err::FileSizeExceededError < ::Curl::Err::CurlError; end
class Curl::Err::FunctionNotFoundError < ::Curl::Err::CurlError; end
class Curl::Err::GotNothingError < ::Curl::Err::CurlError; end
class Curl::Err::HTTP2StreamError < ::Curl::Err::HTTPError; end
class Curl::Err::HTTPError < ::Curl::Err::CurlError; end
class Curl::Err::HTTPFailedError < ::Curl::Err::HTTPError; end
class Curl::Err::HTTPPostError < ::Curl::Err::HTTPError; end
class Curl::Err::HTTPRangeError < ::Curl::Err::HTTPError; end
class Curl::Err::HostResolutionError < ::Curl::Err::CurlError; end
class Curl::Err::IllegalOperationError < ::Curl::Err::TFTPError; end
class Curl::Err::InterfaceFailedError < ::Curl::Err::CurlError; end
class Curl::Err::InvalidLDAPURLError < ::Curl::Err::LDAPError; end
class Curl::Err::InvalidPostFieldError < ::Curl::Err::CurlError; end
class Curl::Err::LDAPError < ::Curl::Err::CurlError; end
class Curl::Err::LibraryNotFoundError < ::Curl::Err::CurlError; end
class Curl::Err::LoginDeniedError < ::Curl::Err::CurlError; end
class Curl::Err::MalformedURLError < ::Curl::Err::CurlError; end
class Curl::Err::MalformedURLUserError < ::Curl::Err::CurlError; end
class Curl::Err::MalformedUserError < ::Curl::Err::CurlError; end
class Curl::Err::MultiAddedAlready < ::Curl::Err::CurlError; end
class Curl::Err::MultiBadEasyHandle < ::Curl::Err::CurlError; end
class Curl::Err::MultiBadHandle < ::Curl::Err::CurlError; end
class Curl::Err::MultiBadSocket < ::Curl::Err::CurlError; end
class Curl::Err::MultiInitError < ::Curl::Err::CurlError; end
class Curl::Err::MultiInternalError < ::Curl::Err::CurlError; end
class Curl::Err::MultiOutOfMemory < ::Curl::Err::CurlError; end
class Curl::Err::MultiPerform < ::Curl::Err::CurlError; end
class Curl::Err::MultiUnknownOption < ::Curl::Err::CurlError; end
class Curl::Err::NoConnectionAvailableError < ::Curl::Err::CurlError; end
class Curl::Err::NoSuchUserError < ::Curl::Err::TFTPError; end
class Curl::Err::NotBuiltInError < ::Curl::Err::CurlError; end
class Curl::Err::NotFoundError < ::Curl::Err::TFTPError; end
class Curl::Err::ObsoleteError < ::Curl::Err::CurlError; end
class Curl::Err::OutOfMemoryError < ::Curl::Err::CurlError; end
class Curl::Err::PPRETFailedError < ::Curl::Err::FTPError; end
class Curl::Err::PartialFileError < ::Curl::Err::CurlError; end
class Curl::Err::PermissionError < ::Curl::Err::TFTPError; end
class Curl::Err::PortFailedError < ::Curl::Err::FTPError; end
class Curl::Err::ProxyResolutionError < ::Curl::Err::CurlError; end
class Curl::Err::RTSPError < ::Curl::Err::CurlError; end
class Curl::Err::ReadError < ::Curl::Err::CurlError; end
class Curl::Err::RecvError < ::Curl::Err::CurlError; end
class Curl::Err::RemoteFileNotFound < ::Curl::Err::CurlError; end
class Curl::Err::SSH < ::Curl::Err::CurlError; end
class Curl::Err::SSLCACertificateError < ::Curl::Err::CurlError; end
class Curl::Err::SSLCRLBadfile < ::Curl::Err::CurlError; end
class Curl::Err::SSLCaertBadFile < ::Curl::Err::CurlError; end
class Curl::Err::SSLCertificateError < ::Curl::Err::CurlError; end
class Curl::Err::SSLConnectError < ::Curl::Err::CurlError; end
class Curl::Err::SSLCypherError < ::Curl::Err::CurlError; end
class Curl::Err::SSLEngineInitFailedError < ::Curl::Err::CurlError; end
class Curl::Err::SSLEngineNotFoundError < ::Curl::Err::CurlError; end
class Curl::Err::SSLEngineSetFailedError < ::Curl::Err::CurlError; end
class Curl::Err::SSLInvalidCertStatusError < ::Curl::Err::CurlError; end
class Curl::Err::SSLIssuerError < ::Curl::Err::CurlError; end
class Curl::Err::SSLPeerCertificateError < ::Curl::Err::CurlError; end
class Curl::Err::SSLPinnedPubKeyNotMatchError < ::Curl::Err::CurlError; end
class Curl::Err::SSLShutdownFailed < ::Curl::Err::CurlError; end
class Curl::Err::SearchFailedError < ::Curl::Err::LDAPError; end
class Curl::Err::SendError < ::Curl::Err::CurlError; end
class Curl::Err::SendFailedRewind < ::Curl::Err::CurlError; end
class Curl::Err::SessionError < ::Curl::Err::RTSPError; end
class Curl::Err::ShareInUseError < ::Curl::Err::CurlError; end
class Curl::Err::TFTPError < ::Curl::Err::CurlError; end
class Curl::Err::TelnetError < ::Curl::Err::CurlError; end
class Curl::Err::TimeoutError < ::Curl::Err::CurlError; end
class Curl::Err::TooManyRedirectsError < ::Curl::Err::CurlError; end
class Curl::Err::UnknownIDError < ::Curl::Err::TFTPError; end
class Curl::Err::UnknownOptionError < ::Curl::Err::TelnetError; end
class Curl::Err::UnsupportedProtocolError < ::Curl::Err::CurlError; end
class Curl::Err::Weird227FormatError < ::Curl::Err::FTPError; end
class Curl::Err::WeirdPassReplyError < ::Curl::Err::FTPError; end
class Curl::Err::WeirdPasvReplyError < ::Curl::Err::FTPError; end
class Curl::Err::WeirdReplyError < ::Curl::Err::FTPError; end
class Curl::Err::WeirdUserReplyError < ::Curl::Err::FTPError; end
class Curl::Err::WriteError < ::Curl::Err::CurlError; end
Curl::HTTP_1_0 = T.let(T.unsafe(nil), Integer)
Curl::HTTP_1_1 = T.let(T.unsafe(nil), Integer)
Curl::HTTP_2_0 = T.let(T.unsafe(nil), Integer)
Curl::HTTP_NONE = T.let(T.unsafe(nil), Integer)
Curl::LONG_VERSION = T.let(T.unsafe(nil), String)

# source://curb//lib/curl/multi.rb#3
class Curl::Multi
  def _add(_arg0); end
  def _close; end
  def _remove(_arg0); end

  # source://curb//lib/curl/multi.rb#269
  def add(easy); end

  # source://curb//lib/curl/multi.rb#255
  def cancel!; end

  # source://curb//lib/curl/multi.rb#283
  def close; end

  # @return [Boolean]
  #
  # source://curb//lib/curl/multi.rb#261
  def idle?; end

  def max_connects=(_arg0); end
  def perform(*_arg0); end
  def pipeline=(_arg0); end

  # source://curb//lib/curl/multi.rb#276
  def remove(easy); end

  # source://curb//lib/curl/multi.rb#265
  def requests; end

  class << self
    def autoclose; end
    def autoclose=(_arg0); end
    def default_timeout; end
    def default_timeout=(_arg0); end

    # call-seq:
    #
    # Curl::Multi.download(['http://example.com/p/a/t/h/file1.txt','http://example.com/p/a/t/h/file2.txt']){|c|}
    #
    # will create 2 new files file1.txt and file2.txt
    #
    # 2 files will be opened, and remain open until the call completes
    #
    # when using the :post or :put method, urls should be a hash, including the individual post fields per post
    #
    # source://curb//lib/curl/multi.rb#187
    def download(urls, easy_options = T.unsafe(nil), multi_options = T.unsafe(nil), download_paths = T.unsafe(nil), &blk); end

    # call-seq:
    #   Curl::Multi.get(['url1','url2','url3','url4','url5'], :follow_location => true) do|easy|
    #     easy
    #   end
    #
    # Blocking call to fetch multiple url's in parallel.
    #
    # source://curb//lib/curl/multi.rb#14
    def get(urls, easy_options = T.unsafe(nil), multi_options = T.unsafe(nil), &blk); end

    # call-seq:
    #
    # Curl::Multi.http( [
    #   { :url => 'url1', :method => :post,
    #     :post_fields => {'field1' => 'value1', 'field2' => 'value2'} },
    #   { :url => 'url2', :method => :get,
    #     :follow_location => true, :max_redirects => 3 },
    #   { :url => 'url3', :method => :put, :put_data => File.open('file.txt','rb') },
    #   { :url => 'url4', :method => :head }
    # ], {:pipeline => Curl::CURLPIPE_HTTP1})
    #
    # Blocking call to issue multiple HTTP requests with varying verb's.
    #
    # urls_with_config: is a hash of url's pointing to the easy handle options as well as the special option :method, that can by one of [:get, :post, :put, :delete, :head], when no verb is provided e.g. :method => nil -> GET is used
    # multi_options: options for the multi handle
    # blk: a callback, that yeilds when a handle is completed
    #
    # source://curb//lib/curl/multi.rb#88
    def http(urls_with_config, multi_options = T.unsafe(nil), &blk); end

    def new; end

    # call-seq:
    #
    #   Curl::Multi.post([{:url => 'url1', :post_fields => {'field1' => 'value1', 'field2' => 'value2'}},
    #                     {:url => 'url2', :post_fields => {'field1' => 'value1', 'field2' => 'value2'}},
    #                     {:url => 'url3', :post_fields => {'field1' => 'value1', 'field2' => 'value2'}}],
    #                    { :follow_location => true, :multipart_form_post => true },
    #                    {:pipeline => Curl::CURLPIPE_HTTP1}) do|easy|
    #     easy_handle_on_request_complete
    #   end
    #
    # Blocking call to POST multiple form's in parallel.
    #
    # urls_with_config: is a hash of url's pointing to the postfields to send
    # easy_options: are a set of common options to set on all easy handles
    # multi_options: options to set on the Curl::Multi handle
    #
    # source://curb//lib/curl/multi.rb#38
    def post(urls_with_config, easy_options = T.unsafe(nil), multi_options = T.unsafe(nil), &blk); end

    # call-seq:
    #
    #   Curl::Multi.put([{:url => 'url1', :put_data => "some message"},
    #                    {:url => 'url2', :put_data => IO.read('filepath')},
    #                    {:url => 'url3', :put_data => "maybe another string or socket?"],
    #                    {:follow_location => true},
    #                    {:pipeline => Curl::CURLPIPE_HTTP1}) do|easy|
    #     easy_handle_on_request_complete
    #   end
    #
    # Blocking call to POST multiple form's in parallel.
    #
    # urls_with_config: is a hash of url's pointing to the postfields to send
    # easy_options: are a set of common options to set on all easy handles
    # multi_options: options to set on the Curl::Multi handle
    #
    # source://curb//lib/curl/multi.rb#62
    def put(urls_with_config, easy_options = T.unsafe(nil), multi_options = T.unsafe(nil), &blk); end
  end
end

# source://curb//lib/curl/multi.rb#4
class Curl::Multi::DownloadError < ::RuntimeError
  # Returns the value of attribute errors.
  #
  # source://curb//lib/curl/multi.rb#5
  def errors; end

  # Sets the attribute errors
  #
  # @param value the value to set the attribute errors to.
  #
  # source://curb//lib/curl/multi.rb#5
  def errors=(_arg0); end
end

Curl::PIPE_HTTP1 = T.let(T.unsafe(nil), Integer)
Curl::PIPE_MULTIPLEX = T.let(T.unsafe(nil), Integer)
Curl::PIPE_NOTHING = T.let(T.unsafe(nil), Integer)

class Curl::PostField
  def content; end
  def content=(_arg0); end
  def content_type; end
  def content_type=(_arg0); end
  def local_file; end
  def local_file=(_arg0); end
  def name; end
  def name=(_arg0); end
  def remote_file; end
  def remote_file=(_arg0); end
  def set_content_proc(*_arg0); end
  def to_s; end
  def to_str; end

  class << self
    def content(*_arg0); end
    def file(*_arg0); end
  end
end

class Curl::Upload
  def offset; end
  def offset=(_arg0); end
  def stream; end
  def stream=(_arg0); end

  class << self
    def new; end
  end
end

Curl::VERNUM = T.let(T.unsafe(nil), Integer)
Curl::VERSION = T.let(T.unsafe(nil), String)
